# server各模块的功能与实现

## 日志系统

server使用的日志系统是一个轻量级的简易日志系统。用户可以调用头文件`Log.h`中提供了四个全局函数`log_debug()`、`log_info()`、`log_warn()`、`log_error()`在控制台上输出不同级别的日志。由于日志系统全局只需要有一个，因此这里使用单例模式（线程安全的懒汉模式）来实现日志系统。

日志系统的输出有四种级别，从低到高分别是：debug、info、warn、error，用户可以在配置文件`config.ini`中指定日志系统当前的输出级别，只有级别不低于指定级别的日志才会被输出（例如在配置文件中指定日志系统当前的输出级别为info，则debug级别的日志在程序实际运行时并不会被输出）。

日志系统有同步和异步两种工作方式，用户也可以在配置文件`config.ini`中指定其工作模式。对于同步模式下的日志系统，当用户调用【日志输出函数】时，程序会同步的将日志打印到控制台上。由于IO是一个比较耗时的操作，频繁的日志IO会导致服务器性能的下降，因此在用户调用【日志输出函数】时，我们先将要打印的日志加到日志队列中，交给一个子线程去IO。

在负责写日志的子线程中，不断的判断日志队列是否为空，如果不为空，则取出日志并输出；如果为空，则使用条件变量阻塞线程（防止线程忙等）。将日志添加到日志队列时，如果发现子线程被阻塞了，则需要唤醒子线程。

注：由于queue是线程不安全的，因此在操作queue时必须加锁，这会导致异步日志系统没法达到应有的性能，下一步的优化方向是使用双缓冲机制实现日志系统（基本思路是，使用两个日志队列A和B，初始时主线程一直向A中写日志，待A写满后，主线程再向B中写日志，此时子线程负责将A中的日志输出。之后主线程再向A中写日志，子线程负责将B中的日志输出，如此循环）。

## 线程池

server使用的线程池是一个轻量级的简易线程池。线程池的主要意义在于直接利用提前构建好的子线程（子线程的数量一般和CPU总核心数相同或接近）处理任务，避免线程频繁创建和销毁的开销。线程池和日志系统一样，采用了单例模式实现。

在初始化线程池时，就需要根据配置文件`config.ini`中指定的线程数量将子线程预先创建好。由于queue是线程不安全的，因此在操作任务队列时必须要加锁。和日志系统不同的是，任务task的执行时间可能很长，有些任务甚至是无限循环，如果不释放掉之前加的锁，就会导致死锁的产生（例如一个工作线程获取锁后执行一个死循环任务，由于该线程没有释放锁，导致其他的工作线程都阻塞在锁的获取上，从而无法从任务队列中取出任务并执行）。又考虑到加锁的目的仅是为了保证操作任务队列时的线程安全，因此将任务取出队列后，就可以先解锁再执行任务，待任务执行完成后，再重新加锁。代码如下：

```c++
std::unique_lock<std::mutex> lock(ThreadPool::instance()->poolLock);
if(!ThreadPool::instance()->taskQue.empty()){
    // 从任务队列中取出任务并执行
    auto task=ThreadPool::instance()->taskQue.front();
    ThreadPool::instance()->taskQue.pop();
    lock.unlock(); // 暂时解锁
    task();
    lock.lock(); // 重新加锁
}else ThreadPool::instance()->condvar.wait(lock); // 如果任务队列为空，则该线程阻塞
```

主线程使用`addTask`函数向任务队列中添加任务，由于queue是线程不安全的，因此在添加任务时必须先加锁。主线程中可以使用`std::bind`将可调用对象及参数封装成一个`function`对象传给`addTask`函数。

注：线程池进一步优化的方向是：使用合理的线程轮转算法，让各个线程的负载尽量相差不大，避免某个或某些线程过载。

## 自增长缓冲区

server使用一个简易的自增长缓冲区。缓冲区分为三个部分：`0～readPos：暂时没有被使用的空间`、`readPos～writePos：可以读的空间（可以把这部分数据读到文件中）`、`writePos～buffer.size：可以写的空间（可以将文件中的数据写到这部分空间中）`。

缓冲区对外提供了两个操作函数：`readFromFile`函数用于从文件中读数据到写空间、`writeToFile`函数用于从读空间向文件中写数据。`writeToFile`的实现较为简单，直接将缓冲区读空间中的可读字节写到文件中即可；

`readFromFile`函数的实现则较为复杂，首先我们创建一个足够大的临时缓冲区，并利用分散读将文件中的数据读到Buffer和临时缓冲区中。如果从文件中读出的数据较少，少于Buffer当前可用的字节数，则Buffer无需扩容；否则需要将Buffer扩容。