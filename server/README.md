# 【服务器】各模块的功能与实现

## 日志系统

server使用的日志系统是一个轻量级的简易日志系统。用户可以调用头文件`Log.h`中提供了四个全局函数`log_debug()`、`log_info()`、`log_warn()`、`log_error()`在控制台上输出不同级别的日志。由于日志系统全局只需要有一个，因此这里使用单例模式（线程安全的懒汉模式）来实现日志系统。日志系统在析构时需要将目前日志队列中的所有日志取出并输出。

日志系统的输出有四种级别，从低到高分别是：debug、info、warn、error，用户可以在配置文件`config.ini`中指定日志系统当前的输出级别，只有级别不低于指定级别的日志才会被输出（例如在配置文件中指定日志系统当前的输出级别为info，则debug级别的日志在程序实际运行时并不会被输出）。

日志系统有同步和异步两种工作方式，用户也可以在配置文件`config.ini`中指定其工作模式。对于同步模式下的日志系统，当用户调用【日志输出函数】时，程序会同步的将日志打印到控制台上。由于IO是一个比较耗时的操作，频繁的日志IO会导致服务器性能的下降，因此在用户调用【日志输出函数】时，我们先将要打印的日志加到日志队列中，交给一个子线程去IO。

在负责写日志的子线程中，不断的判断日志队列是否为空，如果不为空，则取出日志并输出；如果为空，则使用条件变量阻塞线程（防止线程忙等）。将日志添加到日志队列时，如果发现子线程被阻塞了，则需要唤醒子线程。

注：由于queue是线程不安全的，因此在操作queue时必须加锁，这会导致异步日志系统没法达到应有的性能，下一步的优化方向是使用双缓冲机制实现日志系统（基本思路是，使用两个日志队列A和B，初始时主线程一直向A中写日志，待A写满后，主线程再向B中写日志，此时子线程负责将A中的日志输出。之后主线程再向A中写日志，子线程负责将B中的日志输出，如此循环）。

## 线程池

server使用的线程池是一个轻量级的简易线程池。线程池的主要意义在于直接利用提前构建好的子线程（子线程的数量一般和CPU总核心数相同或接近）处理任务，避免线程频繁创建和销毁的开销。线程池和日志系统一样，采用了单例模式实现。线程池在析构时需要将目前任务队列中的所有任务取出并执行。

在初始化线程池时，就需要根据配置文件`config.ini`中指定的线程数量将子线程预先创建好。由于queue是线程不安全的，因此在操作任务队列时必须要加锁。和日志系统不同的是，任务task的执行时间可能很长，有些任务甚至是无限循环，如果不释放掉之前加的锁，就会导致死锁的产生（例如一个工作线程获取锁后执行一个死循环任务，由于该线程没有释放锁，导致其他的工作线程都阻塞在锁的获取上，从而无法从任务队列中取出任务并执行）。又考虑到加锁的目的仅是为了保证操作任务队列时的线程安全，因此将任务取出队列后，就可以先解锁再执行任务，待任务执行完成后，再重新加锁。代码如下：

```c++
std::unique_lock<std::mutex> lock(ThreadPool::instance()->poolLock);
if(!ThreadPool::instance()->taskQue.empty()){
    // 从任务队列中取出任务并执行
    auto task=ThreadPool::instance()->taskQue.front();
    ThreadPool::instance()->taskQue.pop();
    lock.unlock(); // 暂时解锁
    task();
    lock.lock(); // 重新加锁
}else ThreadPool::instance()->condvar.wait(lock); // 如果任务队列为空，则该线程阻塞
```

主线程使用`addTask`函数向任务队列中添加任务，由于queue是线程不安全的，因此在添加任务时必须先加锁。主线程中可以使用`std::bind`将可调用对象及参数封装成一个`function`对象传给`addTask`函数。

注：线程池进一步优化的方向是：使用合理的线程轮转算法，让各个线程的负载尽量相差不大，避免某个或某些线程过载。

对于C++ 11 而言，使用多线程需要包含头文件`#include <thread>`，并且在链接时需要用到`pthread`库。

## 自增长缓冲区

server使用一个简易的自增长缓冲区。缓冲区分为三个部分：`0～readPos：暂时没有被使用的空间`、`readPos～writePos：可以读的空间（可以把这部分数据读到文件中）`、`writePos～buffer.size：可以写的空间（可以将文件中的数据写到这部分空间中）`。

缓冲区对外提供了五个操作函数：`readFromFile`函数用于从文件中读数据到写空间、`writeToFile`函数用于从读空间向文件中写数据、`appendData`函数用于向可写空间中追加数据、`getData`函数用于取出可读空间中的数据、`readData`用于查看可读空间中的数据。

`writeToFile`的实现较为简单，直接将缓冲区读空间中的可读字节写到文件中即可；`readFromFile`函数的实现则较为复杂，首先我们创建一个足够大的临时缓冲区，并利用分散读将文件中的数据读到Buffer和临时缓冲区中。如果从文件中读出的数据较少，少于Buffer当前可用的字节数，则Buffer无需扩容；否则需要将Buffer扩容。其余函数的实现原理类似。

## 数据库连接池

server使用一个轻量级的简易数据库连接池。数据库连接池的主要作用在于：提前创建好一定量的数据库连接，需要进行数据库操作时，就从连接池中取出一个连接并使用，使用完毕后放回到连接池中（连接池采用的数据结构是队列），避免了频繁创建和销毁连接带来的开销。数据库连接池也是通过单例模式实现的。数据库连接池析构时要关闭所有的数据库连接，释放资源。

对于C++而言，连接MySQL需要先安装MySQL及其开发环境，还需要包含头文件`#include <mysql/mysql.g>`，并且在链接时需要用到`mysqlclient`库。`mysql.h`可以在目录`usr/include/mysql`中找到；相关的库文件可以在`usr/lib/x86_64-linux_gun`中找到。（除了MySQL客户端和服务器外，还需要另外安装MySQL开发工具）

项目中的MySQL文件夹包含C++连接MySQL所需的头文件和库文件。

当到达一个HTTP请求时，服务器开启一个子线程来处理这个HTTP请求。为了简化开发，本项目中使用Python脚本来进行业务层的开发，因此子线程需要调用Python代码来处理这一请求。由于在业务中可能需要和数据库交互，因此在开始处理一个请求时，子线程会从MySQL连接池中取出一个连接（如果MySQL连接池繁忙，则阻塞到能取出一个连接为止），并将该连接传递给Python脚本，之后在Python脚本中可以使用该连接与数据库交互。由于无论是32位系统还是64位系统，long类型和指针类型有相同的长度，因此可以使用long类型的数据来传递指针数据，MySQL连接的传递正是这一原理。

## 定时器

server使用的是一个基于小根堆的定时器，定时器中每个节点保存了该节点的id，到期时间，到期时的回调函数。小根堆的堆顶是到期时间最近的节点。小根堆底层使用vector实现，并且使用了一个map记录节点的id到节点在vector中索引的映射，方便根据节点id快速确定节点的位置。由于小根堆底层是使用vector实现的，因此需要自行实现小根堆中节点位置的调整，以及取出小根堆堆顶的代码。

定时器总共提供了四个函数可供外部程序调用：更新一个结点的到期时间、添加一个结点、获取距离最近的到期时间的毫秒数、根据id删除一个制定的节点。

## Python脚本引擎

如果想在C++中调用Python代码，则需要包含Python提供的头文件和相关的库。如果Linux系统下已经安装了相关的Python解释器，则在Python解释器的`include`目录下可以找到相关的头文件（`Python.h`等）；在Python解释器的`lib`目录以及`lib/python3.8/config-3.8-x86_64-linux-gun`（这里使用的Python版本为3.8）目录下可以找到相关的库文件（静态库.a文件和动态库.so文件）。

在Python脚本引擎中，主要提供了五类方法供外部程序调用：初始化Python解释器、导入Python模块、导入Python方法、构造Python参数、调用Python函数。

初始化解释器时需要指定Python脚本所在目录、导入模块时要保证Python文件没有语法错误，否则无法导入、Python的传入参数列表是以元组形式构建的，参数列表中各个参数的值通过一个函数模板指定、调用Python函数时，传入的参数ret用来保存函数的返回值。

项目中Python文件夹包含C++调用Python脚本所必须的头文件和库文件，其相当于一个简化版的Python解释器。以下是安装Python解释器的流程：

```python
1.去Python官网：https://www.python.org 下载Python-3.8.6.tgz（当然也可以下载其他版本，但是该版本是我验证过，可以成功的）
2.使用命令tar -zxvf Python-3.8.6.tgz 打开压缩包
3.安装编译Python所需依赖：apt-get install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make
4.进入 Python-3.8.6 文件夹中，执行：./configure --prefix=/usr/local/python3.8 --enable-shared  --enable-optimizations --enable-static
--prefix 指明了安装Python解释器的位置
--enable-optimizations 是优化选项，加上这个选项编译后，性能有 10% 左右的优化
--enable-static：生成静态链接库
--enable-shared：生成动态链接库
5.进行编译：make
6.进行安装：sudo make altinstall
7./usr/local/python3.8/include下有所需的头文件；/usr/local/python3.8/lib和/usr/local/python3.8/libpython3.8/config-3.8-x86_64-linux-gnu有所需的库文件
```

## 客户端连接封装

本项目中对客户端的连接进行了一定的封装。每个Connection对象中保存了该客户端连接对应的文件描述符、客户端的IP地址和端口、一个可以自动增长的读缓冲区和一个可以自动增长的写缓冲区、HTTP请求头中的重要字段（例如keep-alive）。

Connection类有三个主要的方法：`readFromFile`方法用于将数据从通信套接字的读缓冲区中读到Connection的读缓冲中、`process`方法将会调用HTTP处理器（`HttpProcess`）的方法process，解析读缓冲区中的数据，并将解析结果传递给Python路由器（`prouter`），Python路由器调用相应的处理函数进行业务处理，最后将处理结果返回给process函数，process函数需要根据返回的结果，构造HTTP响应，并将其写入到Connection的写缓冲中。`writeToFile`方法用于将写缓冲中的数据写到通信套接字的写缓冲区中（由内核将这些数据发送出去）。

## 服务器模型

本项目的服务器是基于Reactor并发模型的（主线程只负责accept请求，具体读写和处理任务分发给其它IO线程(兼计算线程)），使用epoll循环检测文件描述符的就绪状态。如果有文件描述符就绪，就依次进行处理：如果是监听套接字就绪，就取出通信套接字的文件描述符并保存起来；如果是读事件就绪，则将相应的方法加到任务队列中，由线程池中的线程依次处理；如果是写事件就绪，也将相应的方法加到任务队列中，由线程池中的线程依次处理。

以下是一些需要注意的细节：

* 本项目中，监听套接字使用水平触发模式（LT），因此不需要循环使用accept进行检测，而通信套接字使用边沿触发模式（ET），因此需要循环使用read读取数据。监听套接字和通信套接字都注册了`EPOLLRDHUP`事件的监听，以可以感知客户端的情况。除此之外，通信套接字还注册了`EPOLLONESHOT`，保证每次就绪时只会触发一次（除非重置监听事件），保证了同时只有一个线程能操作一个socket。
* 本项目中，监听套接字和通信套接字对应的文件描述符都设置为非阻塞的，这是为了防止某个文件描述符的读写阻塞导致其他用户被饿死。
* 在初始化监听套接字时，设置了端口复用和优雅关闭选项。
* 对于客户端的关闭，有两种情况，一种是客户端超时未连接，服务器自动将其清除掉；另一种是客户端主动断开连接。这两种客户端断开连接的情况要使用不同的清理函数释放系统资源（分别是`connectTimeout`和`disconnect`）。

## HTTP处理器

HTTP解析器：逐个字节的读取缓冲区中的数据，如果读到了`\r\n`，则取出该行进行解析。如果当前正在解析请求行，使用一个正则表达式取出请求行中的HTTP版本、请求方法和URL，并将状态设置为解析请求头；如果当前正在解析请求头，使用一个正则表达式取出请求头中的键和值（并把键中的单词的首字母统一设置为小写）；如果某行请求头解析完成后，又读取到了一个空行`\r\n`，则继续解析请求体（请求体的长度在请求头`content-length`中可以得到），如果发现缓冲区中的数据不足以取出指定的大小的请求体，则放弃本次解析，等待后续数据到达。

HTTP构造器：根据HTTP协议版本、状态码和状态描述构造响应行。如果是长连接，则添加响应头`Connection: keep-alive`；由于服务器只支持`json`数据，因此要添加`Content-Type: application/json`响应头；由于服务器只支持GET、POST方法，因此要添加`Access-Control-Allow-Methods: GET,POST`；还要根据响应体的长度添加`Content-Length`响应头。最后，在添加一个空行`\r\n`后添加响应体。

HTTP处理器：先调用HTTP解析器进行HTTP报文的解析，如果解析失败（即报文不完整），则放弃解析，等待后续报文的到达；如果解析成功，先判断是否存在异常情况（比如请求方法不支持等），并返回相应的报文；如果没有异常请求，则要调用Python路由函数，将HTTP解析结果传递给路由函数，进行处理，并根据路由函数的返回结果封装相应的报文（路由函数返回404，则返回404报文；如果路由函数调用失败，则返回500报文；如果路由函数调用成功，则返回200报文）。

注：在调用Python路由函数前要获取一个MySQL连接，并把这个MySQL连接以long类型传递给Python路由函数；在函数调用结束后，要释放该连接。