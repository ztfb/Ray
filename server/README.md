# server各模块的功能与实现

## 日志系统

server使用的日志系统是一个轻量级的简易日志系统。用户可以调用头文件`Log.h`中提供了四个全局函数`log_debug()`、`log_info()`、`log_warn()`、`log_error()`在控制台上输出不同级别的日志。由于日志系统全局只需要有一个，因此这里使用单例模式（线程安全的懒汉模式）来实现日志系统。

日志系统的输出有四种级别，从低到高分别是：debug、info、warn、error，用户可以在配置文件`config.ini`中指定日志系统当前的输出级别，只有级别不低于指定级别的日志才会被输出（例如在配置文件中指定日志系统当前的输出级别为info，则debug级别的日志在程序实际运行时并不会被输出）。

日志系统有同步和异步两种工作方式，用户也可以在配置文件`config.ini`中指定其工作模式。对于同步模式下的日志系统，当用户调用【日志输出函数】时，程序会同步的将日志打印到控制台上。由于IO是一个比较耗时的操作，频繁的日志IO会导致服务器性能的下降，因此在用户调用【日志输出函数】时，我们先将要打印的日志加到日志队列中，交给一个子线程去IO。

在负责写日志的子线程中，不断的判断日志队列是否为空，如果不为空，则取出日志并输出；如果为空，则使用条件变量阻塞线程（防止线程忙等）。将日志添加到日志队列时，如果发现子线程被阻塞了，则需要唤醒子线程。

注：由于queue是线程不安全的，因此在操作queue时必须加锁，这会导致异步日志系统没法达到应有的性能，下一步的优化方向是使用双缓冲机制实现日志系统（基本思路是，使用两个日志队列A和B，初始时主线程一直向A中写日志，待A写满后，主线程再向B中写日志，此时子线程负责将A中的日志输出。之后主线程再向A中写日志，子线程负责将B中的日志输出，如此循环）。

## 线程池

server使用的线程池是一个轻量级的简易线程池。线程池的主要意义在于直接利用提前构建好的子线程（子线程的数量一般和CPU总核心数相同或接近）处理任务，避免线程频繁创建和销毁的开销。线程池和日志系统一样，采用了单例模式实现。

在初始化线程池时，就需要根据配置文件`config.ini`中指定的线程数量将子线程预先创建好。由于queue是线程不安全的，因此在操作任务队列时必须要加锁。和日志系统不同的是，任务task的执行时间可能很长，有些任务甚至是无限循环，如果不释放掉之前加的锁，就会导致死锁的产生（例如一个工作线程获取锁后执行一个死循环任务，由于该线程没有释放锁，导致其他的工作线程都阻塞在锁的获取上，从而无法从任务队列中取出任务并执行）。又考虑到加锁的目的仅是为了保证操作任务队列时的线程安全，因此将任务取出队列后，就可以先解锁再执行任务，待任务执行完成后，再重新加锁。代码如下：

```c++
std::unique_lock<std::mutex> lock(ThreadPool::instance()->poolLock);
if(!ThreadPool::instance()->taskQue.empty()){
    // 从任务队列中取出任务并执行
    auto task=ThreadPool::instance()->taskQue.front();
    ThreadPool::instance()->taskQue.pop();
    lock.unlock(); // 暂时解锁
    task();
    lock.lock(); // 重新加锁
}else ThreadPool::instance()->condvar.wait(lock); // 如果任务队列为空，则该线程阻塞
```

主线程使用`addTask`函数向任务队列中添加任务，由于queue是线程不安全的，因此在添加任务时必须先加锁。主线程中可以使用`std::bind`将可调用对象及参数封装成一个`function`对象传给`addTask`函数。

注：线程池进一步优化的方向是：使用合理的线程轮转算法，让各个线程的负载尽量相差不大，避免某个或某些线程过载。

对于C++ 11 而言，使用多线程需要包含头文件`#include <thread>`，并且在链接时需要用到`pthread`库。

## 自增长缓冲区

server使用一个简易的自增长缓冲区。缓冲区分为三个部分：`0～readPos：暂时没有被使用的空间`、`readPos～writePos：可以读的空间（可以把这部分数据读到文件中）`、`writePos～buffer.size：可以写的空间（可以将文件中的数据写到这部分空间中）`。

缓冲区对外提供了两个操作函数：`readFromFile`函数用于从文件中读数据到写空间、`writeToFile`函数用于从读空间向文件中写数据。`writeToFile`的实现较为简单，直接将缓冲区读空间中的可读字节写到文件中即可；

`readFromFile`函数的实现则较为复杂，首先我们创建一个足够大的临时缓冲区，并利用分散读将文件中的数据读到Buffer和临时缓冲区中。如果从文件中读出的数据较少，少于Buffer当前可用的字节数，则Buffer无需扩容；否则需要将Buffer扩容。

## 数据库连接池

server使用一个轻量级的简易数据库连接池。数据库连接池的主要作用在于：提前创建好一定量的数据库连接，需要进行数据库操作时，就从连接池中取出一个连接并使用，使用完毕后放回到连接池中（连接池采用的数据结构是队列），避免了频繁创建和销毁连接带来的开销。数据库连接池也是通过单例模式实现的。

对于C++而言，连接MySQL需要先安装MySQL及其开发环境，还需要包含头文件`#include <mysql/mysql.g>`，并且在链接时需要用到`mysqlclient`库。`mysql.h`可以在目录`usr/include/mysql`中找到；相关的库文件可以在`usr/lib/x86_64-linux_gun`中找到。（除了MySQL客户端和服务器外，还需要另外安装MySQL开发工具）

项目中的MySQL文件夹包含C++连接MySQL所需的头文件和库文件。

当到达一个HTTP请求时，服务器开启一个子线程来处理这个HTTP请求。为了简化开发，本项目中使用Python脚本来进行业务层的开发，因此子线程需要调用Python代码来处理这一请求。由于在业务中可能需要和数据库交互，因此在开始处理一个请求时，子线程会从MySQL连接池中取出一个连接（如果MySQL连接池繁忙，则阻塞到能取出一个连接为止），并将该连接传递给Python脚本，之后在Python脚本中可以使用该连接与数据库交互。由于无论是32位系统还是64位系统，long类型和指针类型有相同的长度，因此可以使用long类型的数据来传递指针数据，MySQL连接的传递正是这一原理。

## 定时器

server使用的是一个基于小根堆的定时器，定时器中每个节点保存了该节点的id，到期时间，到期时的回调函数。小根堆的堆顶是到期时间最近的节点。小根堆底层使用vector实现，并且使用了一个map记录节点的id到节点在vector中索引的映射，方便根据节点id快速确定节点的位置。由于小根堆底层是使用vector实现的，因此需要自行实现小根堆中节点位置的调整，以及取出小根堆堆顶的代码。

定时器总共提供了四个函数可供外部程序调用：更新一个结点的到期时间、添加一个结点、获取距离最近的到期时间的毫秒数、根据id删除一个制定的节点。

## Python脚本引擎

如果想在C++中调用Python代码，则需要包含Python提供的头文件和相关的库。如果Linux系统下已经安装了相关的Python解释器，则在Python解释器的`include`目录下可以找到相关的头文件（`Python.h`等）；在Python解释器的`lib`目录以及`lib/python3.8/config-3.8-x86_64-linux-gun`（这里使用的Python版本为3.8）目录下可以找到相关的库文件（静态库.a文件和动态库.so文件）。

在Python脚本引擎中，主要提供了五类方法供外部程序调用：初始化Python解释器、导入Python模块、导入Python方法、构造Python参数、调用Python函数。

初始化解释器时需要指定Python脚本所在目录、导入模块时要保证Python文件没有语法错误，否则无法导入、Python的传入参数列表是以元组形式构建的，参数列表中各个参数的值通过一个函数模板指定、调用Python函数时，传入的参数ret用来保存函数的返回值。

项目中Python文件夹包含C++调用Python脚本所必须的头文件和库文件，其相当于一个简化版的Python解释器。以下是安装Python解释器的流程：

```
1.去Python官网：https://www.python.org 下载Python-3.8.6.tgz（当然也可以下载其他版本，但是该版本是我验证过，可以成功的）
2.使用命令tar -zxvf Python-3.8.6.tgz 打开压缩包
3.安装编译Python所需依赖：apt-get install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make
4.进入 Python-3.8.6 文件夹中，执行：./configure --prefix=/usr/local/python3.8 --enable-shared  --enable-optimizations --enable-static
--prefix 指明了安装Python解释器的位置
--enable-optimizations 是优化选项，加上这个选项编译后，性能有 10% 左右的优化
--enable-static：生成静态链接库
--enable-shared：生成动态链接库
5.进行编译：make
6.进行安装：sudo make altinstall
7./usr/local/python3.8/include下有所需的头文件；/usr/local/python3.8/lib和/usr/local/python3.8/libpython3.8/config-3.8-x86_64-linux-gnu有所需的库文件
```